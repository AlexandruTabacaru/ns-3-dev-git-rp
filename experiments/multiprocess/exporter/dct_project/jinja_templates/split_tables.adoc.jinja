:stem:

== Simulation Campaigns "1&2"

Basic L4S implementation (BE queues only â€“ single AP & single station, with & without OBSS interference)  

Purpose: iterate on the L4S implementation with a relatively small set of conditions

Campaign Definition:  All 270 combinations of the following simulation variables:  

* AP Settings (*AP*):
** *AP0*: L4S (DualPI2) disabled
** *AP1*: L4S (DualPI2) enabled
* Traffic Test Cases (*TC*):
** *TC1*: (baseline): single STA with single classic flow
** *TC2*: single STA with single L4S flow  
** *TC3*: single station with 1 L4S and 1 classic flows
** *TC4*: single station with 2 L4S and 2 classic flows
** *TC5*: single station with 4 L4S and 4 classic flows
** All long-running flows for 30 seconds, capturing startup behavior
* Topology Settings (*TS*):
** *TS1*: All with base (wired) RTT of 2 ms
** *TS2*: All with base (wired) RTT of 10 ms
** *TS3*: All with base (wired) RTT of 50 ms
* Link Settings (*LS*):
** *LS1*: 20 MHz MCS 6 
** *LS2*: 80 MHz MCS 6
** *LS3*: 160 MHz MCS 6  
** All with 2 spatial streams, only collision-related retransmissions (no MCS errors/decoding failures), fixed MCS
* OBSS Conditions (*MS*):
** *MS0*: no OBSS
** *MS1*:  Add one additional AP and one associated STA for overlapping traffic 
*** upstream saturating UDP traffic  (600M)
** *MS2*: Similar to MS1, but with one AP and 4 associated STAs, aiming for a fairly high level of channel access contention
*** upstream saturating UDP traffic for each STA (600M / 4)
** no hidden nodes, -45 RSSI, no spatial reuse, 5GHz channel

== Simulation KPIs

****
[options="header"]
|====
|LRR|ratio
|stem:[0]|stem:[1:1]
|stem:[0.1]|stem:[~1.25:1]
|stem:[0.2]|stem:[~1.6:1]
|stem:[0.3]|stem:[~2:1]
|stem:[0.4]|stem:[~2.5:1]
|stem:[0.5]|stem:[~3:1]
|====
****


* Throughput Performance
** *LogRateRatio*, stem:[text(LRR) = log_10(text(rate)_a/text(rate)_b)]
*** Using average per-flow throughput
*** e.g.
**** stem:[rate_a =] average, per-flow Prague throughput
**** stem:[rate_b =] average, per-flow Cubic throughput
*** stem:[0 = 1:1] ratio
*** stem:[+0.3 ~~ 2:1] ratio, stem:[-0.3 ~~ 1:2] ratio
* Latency Performance
** "*Latency Benefit*" stem:[= (text(P99PDV)_b) - (P99PDV_a)]
*** stem:[P99PDV =] 99^th^ percentile packet latency - 1^st^ percentile packet latency
*** Using all packets delivered per flow type

{% if focused_csvs|length > 0 %}
== DualPI2 Prague(a) vs. Cubic(b)

=== Table Legend

[NOTE]
====
.1v1
Comparing performance of a lone prague flow to performance of a lone cubic flow

.n+n
stem:[n] prague flow(s) and stem:[n] cubic flow(s) sharing the link

.Key
[options="header"]
|====
|Cell Data
|0.0 <- LRR +
6.9ms <- Latency Benefit
|====
====

{% endif %}


{% for focused_csv in focused_csvs %}
=== {{ focused_csv.name }}

[.focusedTable]
[options="header"]
[%header,format=csv]
|====
{{ focused_csv.content }}
|====

{% endfor %}

== Detailed Results

[#detailedTable]
[%header,format=csv]
|===
{{ raw_csv }}
|===


ifdef::backend-html5[]
++++
<script>
let detailedTable = new DataTable('#detailedTable', {
    pageLength: 10,
    layout: {
        topStart: 'search',
        topEnd: 'pageLength',
        top2Start: {
            buttons: ['searchBuilder']
        },
        top2End: 'buttons',
    },
    buttons: [{ extend: 'copy', text: 'Copy to clipboard' }, 'csv', 'excel'],
    select: true
});

// The following code highlights LRRs below -0.5 in focused tables.
// This necessarily makes heavy assumptions about the formatting of the tables,
// because we don't have another way to locate the LRR unless we change the code
// that generates the CSVs to include more metadata.
const tableCells = document.querySelectorAll('.focusedTable td');
tableCells.forEach(cell => {
    // Proceed if the cell contains multiple lines
    const cellText = cell.textContent.trim();
    const lines = cellText.split('\n');
    if (lines.length <= 1) {
        return;
    }
//    // Proceed if the first line looks like a negative number
//    const isNegativeNumber = /^-\d+/.test(lines[0]);
//    if (!isNegativeNumber) {
//        return;
//    }
    // If this number is below -0.5 or above 0.5, rewrite the cell to color it bold red
    const num = parseFloat(lines[0]);
    if ((num <= -0.5)||(num >= 0.5)) {
        cell.innerHTML = `<span style="color:red;font-weight:bold;">${lines[0]}</span><br>${lines[1]}`;
    }
});

</script>
++++
endif::backend-html5[]
